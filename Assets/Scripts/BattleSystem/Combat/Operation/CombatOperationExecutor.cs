//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;


public class CombatOperationExecutor
{

	/// <summary>
	/// Executes the physical attack. This will apply the damage and execute the status effects according to the specified Rules.
	/// </summary>
	/// <param name="src">Source.</param>
	/// <param name="dest">Destination.</param>
	/// <param name="action">Action.</param>
	/// <param name="statusList">Status list.</param>
	/// <param name="damageType">Damage type.</param>
	/// <param name="physicalCombatNode">Physical combat node.</param>
	public void ExecutePhysicalAttack(BattleEntity src, BattleEntity dest, 
	                                BattleActionPhysical action,                                   	
	                                CombatStatusEffectList statusList,
	                                DamageType damageType,
	                                ICombatNode physicalCombatNode) {
		CombatResolver offensiveResolver = new CombatResolver (src, physicalCombatNode);
		CombatResolver defensiveResolver = new CombatResolver (dest);
		PhysicalAttackOperation attackOperation = new PhysicalAttackOperation(src, dest, action, damageType);

		ExecuteAttackOperation (attackOperation, offensiveResolver, defensiveResolver, statusList);
	}

	/// <summary>
	/// Executes the magical attack. This will apply the damage and execute the status effects according to the specified Rules.
	/// </summary>
	/// <param name="src">Source.</param>
	/// <param name="dest">Destination.</param>
	/// <param name="action">Action.</param>
	/// <param name="statusList">Status list.</param>
	/// <param name="damageType">Damage type.</param>
	/// <param name="magicalCombatNode">Magical combat node.</param>
	public void ExecuteMagicalAttack(BattleEntity src, BattleEntity dest, 
	                               	 BattleActionMagical action, 
	                                 CombatStatusEffectList statusList,
	                                 DamageType damageType,
	                                 ICombatNode magicalCombatNode) {
		// TODO, move src, dest to resolver type actions exposing raw battle entity
		// remove battle action from event
		// damage type ok
		CombatResolver offensiveResolver = new CombatResolver (src, magicalCombatNode);
		CombatResolver defensiveResolver = new CombatResolver (dest);
		MagicAttackOperation magicOperation = new MagicAttackOperation (src, dest, action, damageType);

		ExecuteAttackOperation (magicOperation, offensiveResolver, defensiveResolver, statusList);
	}

	/// <summary>
	/// Executes the healing. This will not be ignored and will execute all status effects
	/// </summary>
	/// <param name="src">Source.</param>
	/// <param name="dest">Destination.</param>
	/// <param name="action">Action.</param>
	/// <param name="options">Options.</param>
	public void ExecuteHealing(BattleEntity src, BattleEntity dest, 
	                           BattleActionPositive action, 
	                           CombatStatusEffectList statusList,
	                           ICombatNode healingCombatNode) {
		CombatResolver offensiveResolver = new CombatResolver (src, healingCombatNode);
		CombatResolver defensiveResolver = new CombatResolver (dest);
		HealingOperation healOperation = new HealingOperation (src, dest, action);

		// execute and do the healing
		IBattleEvent battleEvent = healOperation.Execute (offensiveResolver, defensiveResolver);

		// notify resulting battle event
		BattleSystem.eventManager.NotifyEvent (battleEvent);

		// since we execute everything, lets just do whatever execute positive to finish the workflow
		ExecutePositive (src, dest, action, statusList);
	}

	/// <summary>
	/// Executes the positive. No damage happens here, we just apply the status effects.
	/// </summary>
	/// <param name="src">Source.</param>
	/// <param name="dest">Destination.</param>
	/// <param name="action">Action.</param>
	/// <param name="statusList">Status list.</param>
	public void ExecutePositive(BattleEntity src, BattleEntity dest, 
	                            BattleActionPositive action, 
	                            CombatStatusEffectList statusList) {
		foreach (CombatStatusEffect combatStatusEffect in statusList.statusEffects) {
			ApplyEffect(combatStatusEffect, src);
		}
	}

	/// <summary>
	/// Execute an operation and manage check resulting event with CombatStatusEffect Rules if any
	/// </summary>
	/// <param name="operation">Operation.</param>
	private void ExecuteAttackOperation(ICombatOperation operation, CombatResolver srcResolver, CombatResolver destResolver, CombatStatusEffectList statusList) {
		// check to see if we were alive before executing the event
		BattleEntity destEntity = destResolver.entity;
		bool wasAlive = destEntity.currentHP > 0;

		// execute and apply damage
		IBattleEvent battleEvent = operation.Execute (srcResolver, destResolver);

		// notify resulting battle event
		BattleSystem.eventManager.NotifyEvent (battleEvent);

		// check to see if it was a damage event to see if we killed them
		if (battleEvent.eventType == BattleEventType.DAMAGE && wasAlive && destEntity.currentHP <= 0) {
			destEntity.character.curHP = 0;
			DeathEvent deathEvent = new DeathEvent(destEntity);
			BattleSystem.eventManager.NotifyEvent(deathEvent);		
		}

		// lets see if we hit the target or not
		bool hitTarget = battleEvent.eventType == BattleEventType.DAMAGE
						|| battleEvent.eventType == BattleEventType.NON_DAMAGE 
						|| battleEvent.eventType == BattleEventType.ITEM;

		bool missedTarget = battleEvent.eventType == BattleEventType.DODGE
						|| battleEvent.eventType == BattleEventType.RESIST;

		// iterate through combnat effects to see what should apply
		foreach (CombatStatusEffect combatStatusEffect in statusList.statusEffects) {
			switch(combatStatusEffect.rule) {			
			case CombatStatusEffect.StatusEffectRule.ON_HIT:
				if(hitTarget) {
					ApplyEffect(combatStatusEffect, srcResolver.entity);
				}
				break;
			case CombatStatusEffect.StatusEffectRule.ON_MISS:
				if(missedTarget) {
					ApplyEffect(combatStatusEffect, srcResolver.entity);
				}
				break;
			case CombatStatusEffect.StatusEffectRule.ALWAYS:
			default:
				ApplyEffect(combatStatusEffect, srcResolver.entity);
				break;
			}
		}
	}

	/// <summary>
	/// Applies the effect. Notify the StatusEffect to the event manager
	/// </summary>
	/// <param name="effects">Effects.</param>
	/// <param name="targetEntity">Target entity.</param>
	private void ApplyEffect(CombatStatusEffect combatEffect, BattleEntity srcEntity) {
		BattleEntity destEntity = combatEffect.target;
		IStatusEffect statusEffect = combatEffect.effect;
		// first directly apply the effect
		destEntity.ApplyStatusEffect (statusEffect);
		// then create an event to notify that there has been some event for this status effect
		IBattleEvent statusEvent = new StatusEffectEvent (srcEntity, destEntity, statusEffect);
		BattleSystem.eventManager.NotifyEvent(statusEvent);
	}
	
	// calculate and apply damage state (see if they are dead or not)
	private void PostDamageEvent(DamageEvent dmgEvent) {
		BattleEntity destEntity = dmgEvent.destEntity;
		// if character died, notify death event
		if(destEntity.character.curHP <= 0) {
			destEntity.character.curHP = 0;
			DeathEvent deathEvent = new DeathEvent(destEntity);
			BattleSystem.eventManager.NotifyEvent(deathEvent);
		}

	}		
}
