//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;

public class MagicAttackOperation : AbstractCombatOperation
{
	private const float CRIT_MULTIPLIER_LOW = 1.5f;
	private const float CRIT_MULTIPLIER_HIGH = 1.8f;
	
	private BattleEntity mSrcEntity;
	private BattleEntity mDestEntity;

	private DamageType mDamageType;
	private bool mHasDamage;
	private bool mIsResisted;
	private bool mIsCrit;
	private float mTotalDamage;
	
	public MagicAttackOperation (BattleEntity src, BattleEntity dest, BattleActionMagical action, DamageType damageType, CombatResolver offensiveResolver)
	{
		this.mSrcEntity = src;
		this.mDestEntity = dest;
		this.mDamageType = damageType;
		
		mIsResisted = false;
		mIsCrit = false;



	}

	public override void Execute (CombatResolver srcResolver, CombatResolver destResolver)
	{
		// check dodge before anything
		float resistValue = destResolver.GetResist(mDamageType); 
		float power = srcResolver.GetMagicalPower ();
		float chanceToResist = power / (power + resistValue);
		
		// TODO add chanceToHit increase
		if(UnityEngine.Random.Range(0f, 1f) > chanceToResist) {
			// missed
			mIsResisted = true;
			return;
		}
		
		float dmg = srcResolver.GetMagicalDamage();
		
		if(dmg == 0) {
			mHasDamage = false;
			return; // no reason to do additional calculations, no damage applied
		}
		
		// Calculate damage
		float damageSum = UnityEngine.Random.Range(dmg * 0.8f, dmg * 1.2f); // tmp
		
		// calculate crit chance
		float srcCritChance = srcResolver.GetCritChance ();
		float destCritDefense = destResolver.GetCritDefense ();
		float critChance = srcCritChance / (srcCritChance + destCritDefense); 
		// TODO factor in other chances
		if(UnityEngine.Random.Range(0f, 1f) <= critChance) {
			damageSum *= UnityEngine.Random.Range(CRIT_MULTIPLIER_LOW, CRIT_MULTIPLIER_HIGH); // crit
			mIsCrit = true;
		}
		
		
		// now calculate damage reduction from opponent
		// TODO override dmg type if special attack?

		
		// result damage should be same type of calculation
		mTotalDamage = damageSum * damageSum / (damageSum + resistValue);
		mTotalDamage = Mathf.Ceil(mTotalDamage);

		ExecuteDamage (mTotalDamage);
	}
}

