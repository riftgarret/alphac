//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;

public class HealingOperation : AbstractCombatOperation
{
	private BattleEntity mSrcEntity;
	private BattleEntity mDestEntity;

	public HealingOperation (BattleEntity src, BattleEntity dest)
	{
		this.mSrcEntity = src;
		this.mDestEntity = dest;
	}

	public override IBattleEvent Execute (CombatResolver srcResolver, CombatResolver destResolver)
	{
		// this is used for healing as well
		float healing = srcResolver.GetMagicalDamage();
		
		// Calculate damage
		float healingSum = UnityEngine.Random.Range(healing * 0.8f, healing * 1.2f); // tmp
		
		// calculate crit chance
		float srcCritChance = srcResolver.GetCritChance ();
		float destCritDefense = destResolver.GetCritDefense ();
		// as opposed to crit defense reducing the chance, it will increase the chance
		float critChance = 1f - (srcCritChance / (srcCritChance + destCritDefense)); 

		float critHealing = 0f;
		if(UnityEngine.Random.Range(0f, 1f) <= critChance) {
			// lets separate crit damage from normal for sake of event
			critHealing = Mathf.Ceil(UnityEngine.Random.Range(CRIT_MULTIPLIER_LOW, CRIT_MULTIPLIER_HIGH)); // crit
		}

		// result damage should be same type of calculation
		healingSum = Mathf.Ceil(healingSum);

		float totalHealing = healingSum + critHealing;

		ExecuteHealing(totalHealing, mDestEntity);
		// return damage event
		return new HealEvent(mSrcEntity, mDestEntity, healingSum, critHealing);
	}
}

