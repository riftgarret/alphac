//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;

public class DamageEvent
{
	private const float CRIT_MULTIPLIER = 1.5f;

	private BattleEntity srcEntity;
	private BattleEntity destEntity;

	private List<DamageNode> damageNodes;
	private bool isEvaded;
	private bool isCrit;


	public DamageEvent (BattleEntity srcEntity, BattleEntity destEntity, BattleAction action, OffensiveModifier [] skillModifiers)
	{
		isEvaded = false;
		isCrit = false;

		// should be done first to popualte into from auxilary methods
		damageNodes = new List<DamageNode>();

		// get the main weapon to determine damage type
		Character srcChar = srcEntity.character;	
		Character destChar = destEntity.character;

		// check dodge before anything
		float chanceToHit = srcChar.accuracy / (srcChar.accuracy / destChar.relfex);

		// TODO add chanceToHit increase
		if(UnityEngine.Random.Range(0f, 1f) > chanceToHit) {
			// missed
			isEvaded = true;
			return;
		}


		// Calculate damage
		Weapon weapon = srcChar.mainHandWeapon;				
						
		float dmg = weapon.weaponConfig.baseDamage;
		float rolledDmg = UnityEngine.Random.Range(dmg * 0.8f, dmg * 1.2f); // tmp

		// we want to annotate the damage from each feature
		CalculatePreDamage(OffensiveSourceType.WEAPON, rolledDmg, weapon.weaponConfig.offensiveModifiers, srcChar);
		//inscriptionDmgNode = null; // TODO
		CalculatePreDamage(OffensiveSourceType.SKILL, rolledDmg, action.combatSkill.combatSkillConfig.offensiveModifiers, srcChar);
		// effectDmgNode = null; // TODO

		// calculate weapon damage node
		float damageSum = rolledDmg;
		foreach(DamageNode node in damageNodes) {
			damageSum += node.calculatedDamage;
		}

		// calculate crit chance
		float critChance = srcChar.critChance / (srcChar.critChance / destChar.critDefense);
		// TODO factor in other chances
		if(UnityEngine.Random.Range(0f, 1f) <= critChance) {
			damageSum *= CRIT_MULTIPLIER; // crit
			isCrit = true;
		}

		// now calculate damage reduction from opponent
		// TODO override dmg type if special attack
		destChar.GetResist(weapon.weaponConfig.dmgType);
	}

	/*
	 * TOTAL_DMG,
	CRIT_MOD,
	CRIT_TOTAL,
	ARMOR_IGNORE,
	DODGE_IGNORE,
	STR_MOD,
	AGI_MOD,
	DEX_MOD,
	INT_MOD,
	WIS_MOD
	 */

	/// <summary>
	/// Calculates the pre damage. this is so we can break out each group up
	/// </summary>
	/// <returns>The pre damage.</returns>
	/// <param name="srcType">Source type.</param>
	/// <param name="initialDamage">Initial damage.</param>
	/// <param name="statModifiers">Stat modifiers.</param>
	/// <param name="c">C.</param>
	private DamageNode CalculatePreDamage(OffensiveSourceType srcType, float initialDamage, OffensiveModifier[] modifiers, Character c) {
		// if no modifiers, lets return null to skip in  our log
		if(modifiers == null) {
			return null;
		}

		float moddedDmg = 0;
		foreach(OffensiveModifier mod in modifiers) {
			moddedDmg += c.GetNativeStat(mod.type) * mod.modValue;
		}
		// if we are still 0, return null so we don't include it in our log
		if(moddedDmg == 0) {
			return null;
		}

		/// create and add it to our list
		DamageNode node = new DamageNode(initialDamage * moddedDmg, srcType);
		damageNodes.Add(node);

		return node;
	}

	public class DamageNode {
		public readonly float calculatedDamage;
		public readonly OffensiveSourceType srcType;

		public DamageNode(float dmg, OffensiveSourceType type) {
			this.calculatedDamage = dmg;
			this.srcType = type;
		}
	}

}


