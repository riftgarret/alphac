//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Status effect manager. To manage buffs, debuffs and other states that may or may not be curable
/// </summary>
public class StatusEffectManager
{
	// for fast access to get those effects
	private Dictionary<StatusEffectGroupSO, StatusEffectNode> mEffectNodeMap;
	// TODO should have a sorted list of status effects for sake of loading GUI
	private BattleEntity mBattleEntity;

	/// <summary>
	/// Initializes a new instance of the <see cref="StatusEffectManager"/> class.
	/// </summary>
	/// <param name="entity">The Entity to manage. </param>
	public StatusEffectManager (BattleEntity entity)
	{
		mEffectNodeMap = new Dictionary<StatusEffectGroupSO, StatusEffectNode>();
		mBattleEntity = entity;
	}
	
	/// <summary>
	/// Handles the add status.
	/// </summary>
	/// <param name="effect">Effect.</param>
	/// <param name="printLog">If set to <c>true</c> print log.</param>
	public void HandleAddStatus(IStatusEffectExecutor effect) {
		StatusEffectNode node = mEffectNodeMap[effect.statusEffectGroup];
		if(node == null) {
			node = new StatusEffectNode(this);
			mEffectNodeMap[effect.statusEffectGroup] = node;
		}

		node.ApplyEffect(effect);
	}

	/// <summary>
	/// Raises the time increment event.
	/// </summary>
	/// <param name="timeDelta">Time delta.</param>
	public void OnTimeIncrement(float timeDelta) {
		foreach(StatusEffectGroupSO key in mEffectNodeMap.Keys) {
			mEffectNodeMap[key].IncrementTime(timeDelta);
		}
	}	

	// An internal data structure to manage the possible single instance types of these types of
	// buffs and debuffs being applied. Using a Chain of Responsibility pattern to delegate its rules
	// for clearing, and rebuffing.
	class StatusEffectNode {
		// TODO return node type, so we can easily grab attributes from 

		// even though we cant have a magical debuff and magical buff at the same time
		// its a lot less tedious to debug if we just have separate pointers
		private IStatusEffectExecutor [] executors;

		private StatusEffectManager parent;

		public StatusEffectNode(StatusEffectManager manager) {
			this.parent = manager;
			executors = new IStatusEffectExecutor[(int)StatusEffectType.COUNT];
		}

		public void ApplyEffect(IStatusEffectExecutor effect) {
			StatusEffectType type = effect.effectType;

			switch(type) {
			case StatusEffectType.MAGICAL_BUFF:
				ApplyEffect(effect, executors[(int)StatusEffectType.MAGICAL_DEBUFF]);
				break;
			case StatusEffectType.MAGICAL_DEBUFF:
				ApplyEffect(effect, executors[(int)StatusEffectType.MAGICAL_BUFF]);
				break;
			case StatusEffectType.PHYSICAL_DEBUFF:
				ApplyEffect(effect, null);
				break;
			}

		}

		/// <summary>
		/// Applies the magical buff effect. If we have a debuff, lets remove it instead.
		/// </summary>
		/// <param name="effect">Effect.</param>
		private void ApplyEffect(IStatusEffectExecutor effect, IStatusEffectExecutor oppositeEffect) {
			if(oppositeEffect != null) {
				RemoveEffect(oppositeEffect.effectType, StatusEffectEvent.StatusEventType.REMOVED);
			}
			else {
				AddEffect(effect);
			}
		}

		/// <summary>
		/// If this execotor slot exists, remove it and fire the event type to the EventManager
		/// </summary>
		/// <param name="effectType">Effect type.</param>
		/// <param name="eventType">Event type.</param>
		private void RemoveEffect(StatusEffectType effectType, StatusEffectEvent.StatusEventType eventType) {
			IStatusEffectExecutor oldEffect = executors[(int)effectType];
			if(oldEffect != null) {
				executors[(int)effectType] = null;
				BattleSystem.eventManager.NotifyEvent(new StatusEffectEvent(parent.mBattleEntity, oldEffect, eventType));
			}
		}

		/// <summary>
		/// Adds the effect. Then notify the EventManager
		/// </summary>
		/// <param name="effect">Effect.</param>
		private void AddEffect(IStatusEffectExecutor effect) {
			if(effect != null) {
				// if existing effect exists, lets replace it using that eventType
				StatusEffectType effectType = effect.effectType;
				StatusEffectEvent.StatusEventType eventType = executors[(int)effectType] != null? 
					StatusEffectEvent.StatusEventType.REPLACED 
						: StatusEffectEvent.StatusEventType.NEW;

				executors[(int)effectType] = effect;
				// notify listeners
				BattleSystem.eventManager.NotifyEvent(new StatusEffectEvent(parent.mBattleEntity, effect, eventType));
			}
		}


		/// <summary>
		/// Increments the time. Potential place for expiring an event
		/// </summary>
		/// <param name="timeDelta">Time delta.</param>
		public void IncrementTime(float timeDelta) {
			foreach(IStatusEffectExecutor executor in executors) {
				if(executor != null) {
					executor.IncrementDurationTime(timeDelta);

					if(executor.isExpired) {
						RemoveEffect(executor.effectType, StatusEffectEvent.StatusEventType.EXPIRED);
					}
				}
			}
		}

		bool isEmpty {
			get { 
				foreach(IStatusEffectExecutor executor in executors) {
					if(executor != null) {
						return false;
					}
				}
				return true;
			}
		}
	}
}


