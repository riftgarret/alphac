//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Status effect manager. To manage buffs, debuffs and other states that may or may not be curable
/// </summary>
public class StatusEffectManager
{
	// for fast access to get those effects
	private Dictionary<StatusEffectGroupSO, StatusEffectNode> mEffectNodeMap;
	// TODO should have a sorted list of status effects for sake of loading GUI
	private BattleEntity mBattleEntity;

	/// <summary>
	/// Initializes a new instance of the <see cref="StatusEffectManager"/> class.
	/// </summary>
	/// <param name="entity">The Entity to manage. </param>
	public StatusEffectManager (BattleEntity entity)
	{
		mEffectNodeMap = new Dictionary<StatusEffectGroupSO, StatusEffectNode>();
		mBattleEntity = entity;
	}
	
	/// <summary>
	/// Handles the add status.
	/// </summary>
	/// <param name="effect">Effect.</param>
	/// <param name="printLog">If set to <c>true</c> print log.</param>
	public bool HandleAddStatus(IStatusEffectExecutor effect) {
		StatusEffectNode node = mEffectNodeMap[effect.statusEffectGroup];
		if(node == null) {
			node = new StatusEffectNode(this);
			mEffectNodeMap[effect.statusEffectGroup] = node;
		}

		return node.ApplyEffect(effect);
	}

	private void RemoveEffect(IStatusEffectExecutor effect, bool printLog) {
		StatusEffectNode node = mEffectNodeMap[effect.statusEffectGroup];
		if(node != null) {
			node.RemoveEffect(effect);
		}
	}

	public void OnTimeIncrement(float timeDelta) {
		LinkedList<IStatusEffectExecutor> removalQueue = null; // lazy init this if it needs to be made
		foreach(IStatusEffectExecutor effect in mKeyedEffectMap.Values) {
			effect.IncrementDurationTime(timeDelta);

			if(effect.currentDurationLength <= 0) {
				// add to queue
				if(removalQueue == null) {
					removalQueue = new LinkedList<IStatusEffectExecutor>();
				}
				removalQueue.AddLast(effect);
			}
		}

		if(removalQueue != null) {
			foreach(IStatusEffectExecutor effect in removalQueue) {
				RemoveEffect(effect, true);
			}
		}
	}	

	// An internal data structure to manage the possible single instance types of these types of
	// buffs and debuffs being applied. Using a Chain of Responsibility pattern to delegate its rules
	// for clearing, and rebuffing.
	class StatusEffectNode {
		// TODO return node type, so we can easily grab attributes from 

		// even though we cant have a magical debuff and magical buff at the same time
		// its a lot less tedious to debug if we just have separate pointers
		private IStatusEffectExecutor physicalExecutor;
		private IStatusEffectExecutor magicalDebuffExecutor;
		private IStatusEffectExecutor magicalBuffExecutor;

		private StatusEffectManager parent;

		public StatusEffectNode(StatusEffectManager manager) {
			this.parent = manager;
		}

		public bool ApplyEffect(IStatusEffectExecutor effect) {
			StatusEffectType type = effect.effectType;

			switch(type) {
			case StatusEffectType.MAGICAL_BUFF:
				return ApplyMagicalBuffEffect(effect);
			case StatusEffectType.MAGICAL_DEBUFF:
				return ApplyMagicalDebuffEffect(effect);
			case StatusEffectType.PHYSICAL_DEBUFF:
				return ApplyPhysicalDebuffEffect(effect);
			}
			// 
			Debug.Log("Somehow tried to apply a non-magical/physical effect: " + effect);
			return false;
		}

		/// <summary>
		/// Applies the magical buff effect. If we have a debuff, lets remove it instead.
		/// </summary>
		/// <param name="effect">Effect.</param>
		private bool ApplyMagicalBuffEffect(IStatusEffectExecutor effect) {
			if(magicalDebuffExecutor != null) {
				magicalDebuffExecutor = null;
				return false;
			}

			magicalBuffExecutor = effect;
			return true;
		}

		/// <summary>
		/// Applies the magical buff effect. If we have a debuff, lets remove it instead.
		/// </summary>
		/// <param name="effect">Effect.</param>
		private bool ApplyMagicalDebuffEffect(IStatusEffectExecutor effect) {
			if(magicalBuffExecutor != null) {
				magicalBuffExecutor = null;
				return false;
			}
			
			magicalDebuffExecutor = effect;
			return true;
		}

		private bool ApplyPhysicalDebuffEffect(IStatusEffectExecutor effect) {
			physicalExecutor = effect;
			return true;
		}

		public void RemoveEffect(IStatusEffectExecutor effect) {
			StatusEffectType type = effect.effectType;
			
			switch(type) {
			case StatusEffectType.MAGICAL_BUFF:
				if(magicalBuffExecutor == effect) {
					magicalBuffExecutor = null;
					BattleSystem.eventManager.NotifyEvent(new StatusEffectEvent());
				}
				return;
			case StatusEffectType.MAGICAL_DEBUFF:
				if(magicalDebuffExecutor == effect) {
					magicalDebuffExecutor = null;
				}
				return;
			case StatusEffectType.PHYSICAL_DEBUFF:
				if(physicalExecutor == effect) {
					physicalExecutor = null;
				}
				return;
			}
		}

		bool isEmpty {
			get { return magicalDebuffExecutor == null && physicalExecutor == null && magicalBuffExecutor == null; }
		}
	}
}


