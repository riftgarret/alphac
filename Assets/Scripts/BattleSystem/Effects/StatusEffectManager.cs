//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Status effect manager. To manage buffs, debuffs and other states that may or may not be curable
/// </summary>
public class StatusEffectManager
{
	// for fast access to get those effects
	private Dictionary<EffectType, LinkedList<IStatusEffect>> mSkillTypeEffectMap;
	private Dictionary<string, IStatusEffect> mKeyedEffectMap;
	private BattleEntity mBattleEntity;

	/// <summary>
	/// Initializes a new instance of the <see cref="StatusEffectManager"/> class.
	/// </summary>
	/// <param name="entity">The Entity to manage. </param>
	public StatusEffectManager (BattleEntity entity)
	{
		mSkillTypeEffectMap = new Dictionary<EffectType, LinkedList<IStatusEffect>>();
		mKeyedEffectMap = new Dictionary<string, IStatusEffect>();
		mBattleEntity = entity;
	}

	/// <summary>
	/// Gets the effect list. If one does not exist, it will be made.
	/// </summary>
	/// <returns>The effect list.</returns>
	/// <param name="type">Type.</param>
	private LinkedList<IStatusEffect> GetEffectList(EffectType type) {
		if(! mSkillTypeEffectMap.ContainsKey(type)) {
			mSkillTypeEffectMap[type] = new LinkedList<IStatusEffect>();
		}
		return mSkillTypeEffectMap[type];
	}

	/// <summary>
	/// Handles the add status.
	/// </summary>
	/// <param name="effect">Effect.</param>
	/// <param name="printLog">If set to <c>true</c> print log.</param>
	public void HandleAddStatus(IStatusEffect effect) {
		// check to see if this already exists
		if(mKeyedEffectMap.ContainsKey(effect.statusKey)) {
			// lets see if this is a reversable action, as in, lets remove the debuff / buff
			IStatusEffect currentEffect = mKeyedEffectMap[effect.statusKey];
			// lets remove it, either action we will do will be to replace it or keep it removed
			RemoveEffect(currentEffect, false);
			// if these were opposite effects, lets not readd it
			if(currentEffect.sourceType != effect.sourceType) {
				return; 
			}
		}

		// Add the effect
		AddEffect(effect, true);
	}


	private void AddEffect(IStatusEffect effect, bool printLog) {
		mSkillTypeEffectMap[effect.effectType].AddLast(effect);
		mKeyedEffectMap[effect.statusKey] = effect;
	}

	private void RemoveEffect(IStatusEffect effect, bool printLog) {
		// remove from all lists
		mSkillTypeEffectMap[effect.effectType].Remove(effect);
		mKeyedEffectMap.Remove(effect.statusKey);

		if(printLog) {
			Debug.Log(effect.GetTextOnDettach(mBattleEntity));
		}
	}

	public void OnTimeIncrement(float timeDelta) {
		LinkedList<IStatusEffect> removalQueue = null; // lazy init this if it needs to be made
		foreach(IStatusEffect effect in mKeyedEffectMap.Values) {
			effect.IncrementDurationTime(timeDelta);

			if(effect.currentDurationLength <= 0) {
				// add to queue
				if(removalQueue == null) {
					removalQueue = new LinkedList<IStatusEffect>();
				}
				removalQueue.AddLast(effect);
			}
		}

		if(removalQueue != null) {
			foreach(IStatusEffect effect in removalQueue) {
				RemoveEffect(effect, true);
			}
		}
	}	
}


